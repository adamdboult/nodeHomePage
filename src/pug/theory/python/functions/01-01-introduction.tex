
\subsection{SORT}

passing arrays to functions. what is passed? reference ot first? length separately?

\subsection{Defining functions}

Best practice is to name them \(lower\_case\_and\_underscore\).

Everything including functions are objects. As a result functions are first class. Functions can accept functions and can return functions.

\begin{verbatim}

def my_function_no_parameters():
    return 0
    
def my_function_with_parameters(x, y):
    return x + y

\end{verbatim}

\subsection{Decorators}

apply @ function to function below to decorate it. syntactic sugar

\begin{verbatim}

def my_decorator(func):
    def inner(a):
        print("Printing ", a, " in a decorated way")
        return
    return inner
    
@my_decorator
def just_printing(a):
    print(a)

\end{verbatim}

\subsection{Default parameters}

\begin{verbatim}
def f(a: int = 1, b: int = 2) -> int:
    return a + b
\end{verbatim}

\subsection{Side effects of functions}

Can have side effects on objects in parameters if mutable.

Can have side effects on global variables if present.

\subsection{Passing lists and objects to functions rather than doing literally}

\begin{verbatim}
def f(a, b):
    return a + b
\end{verbatim}

Can accept multiple variables with *arguments

\begin{verbatim}
l=[1,2]
f(*l)
\end{verbatim}

Or can accept named literals with **kwargs (ie key word arguments)

\begin{verbatim}
args = {"a":1, "b":2}
f(**args)
\end{verbatim}

\subsection{Main function in python}

\begin{verbatim}
def main():
    // Do stuff
if __name__ == "__main__":
    main()
\end{verbatim}

\subsection{Generators and the yield function}

functions which make generators: yield function


