
\subsection{SORT}


list slice:

\begin{verbatim}
v[1:3]
\end{verbatim}


+ can also do third thing?

 reverses???
\begin{verbatim}
v[::-1]
\end{verbatim}

  
\subsection{Introduction}

Python get array size,  size of other iterables, sets

map and filters run on iterable. also the loops?
is a set an iterable?

+ conditional substitutions of lists in python

\subsection{Lists}

Python lists are dynamic arrays.

\begin{verbatim}
a = [1,2,3]
\end{verbatim}

Lists are mutable.


How to do each of following:

concatenation

slice/filter

insert

pop

traverse

map

sort

reverse

\subsection{List slices}

\subsection{List comprehensions}

Eg the following defines a list, and then the second line returns that list.

\begin{verbatim}
my_list = [1,2,3]
[x for x in my_list]
\end{verbatim}

can do functions too. following returns [3,4,5]
\begin{verbatim}
[x + 2 for x in my_list]
\end{verbatim}

filter

\begin{verbatim}
[x for x in my_list if x >2]
\end{verbatim}

can be on any iterable:

\begin{verbatim}
[x for x in range(10)]
\end{verbatim}

\subsection{Lambda functions}
filter

+ map function
+ lambda functions

\subsection{Tuples}

\begin{verbatim}
a = (1,2,3)
\end{verbatim}

Tuples are immutable.

why not just use copy on write instead of tuples?
+ complex to implement?

why tuples
broadly safety
+ mean that if create one tuple based on another, deep copy?
if mutable
+ a=(1,2,3)
+ b=a
+ b[0]=2
  * this fails, but if it didn't we might get the following
+ print(a)
  * (2,2,3)
+ print(b)
  * (2,2,3)

with mutability can still do eg a=a[2] because this is creating a new thing and using it in name
immutability means can't do eg b[3] = 2
allows optimiser to assume not mutable. can cause speed ups

