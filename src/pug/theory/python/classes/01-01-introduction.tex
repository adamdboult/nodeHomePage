
\subsection{Instance methods and the init constructor}

\begin{verbatim}

class MyClass:

    def __init__(self, name):
        self.name = name
        self.data = []

    def do_something(self, x):
        self.data.append(x)

myObject = MyClass("bob")

\end{verbatim}

Or optionally with type hints:

\begin{verbatim}
myObject: MyClass = MyClass("bob")

\end{verbatim}

\subsection{Class documentation}

\begin{verbatim}

class MyClass:

    """
    Documentation of class
    """

    def do_something(self, x):
        """Documentation of method"""
        self.data.append(x)
        
\end{verbatim}

\subsection{Global variables in classes and class methods}

Need to use decorators for classmethod and staticmethod to get them to work properly, though possibly being phased out?

\begin{verbatim}

class MyClass:

    x = 1

    def __init__(self, name):
        self.name = name
        self.data = []
    
    @classmethod
    def do_something(cls, y):
        cls.x = y
        
\end{verbatim}

\subsection{Static methods}

\begin{verbatim}

class MyClass:

    @staticmethod
    def do_something(x):
        print(x)
        
\end{verbatim}

\subsection{Getaddr and setaddr}

Can be used to validate data, present properly and ensure encapsulation.

\begin{verbatim}

    __getaddr__

\end{verbatim}

\begin{verbatim}

    __setaddr__

\end{verbatim}
 
\begin{verbatim}

    __deladdr__

\end{verbatim}

\subsection{Class destructor}

Called when object deleted (eg by garbage collector or "del myObject")

\begin{verbatim}

class MyClass:

    def __init__(self, name):
        self.name = name
        self.data = []

    def __del__(self):
        pass
        
\end{verbatim}

\subsection{Replacing built in functions}

\begin{verbatim}

class MyClass:

    def __init__(self, things):
        self.things = things

    def __len__(self):
        return len(self.things)
        
\end{verbatim}

\subsection{Operator overloading}

Can overload other operators too.
\begin{verbatim}

class MyClass:

    def __init__(self, val):
        self.val = val

    def __add__(self, other):
        return len(self.val + other.val)

x = MyClass(1)
y = MyClass(2)
x + y
        
\end{verbatim}

\subsection{Class iterators}

\begin{verbatim}

__iter__

__next__
\end{verbatim}

