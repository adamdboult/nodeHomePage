
\subsection{Introduction}

frame explicitly as discrete search and discrete optimisation. discrete counting, discrete function problem, discrete decision,

on complexity classes: modular exponention vs discrete logarithm. one much harder than other. used for crypto
3 crypto problems to highlight
+ integer factorisation
+ discrete logarithm problem
+ eliptic curve

boolean satisfiability problem
given propositional logic statement, can we find assignment where statement is true
brute force exists, but is exponential
proven to be NP-complete

hard discrete logarith problem
+ Q=kP for some Q and P on curve, and k integer
+ easy to find Q given k and P

elliptic curve point multiplication
+ double-and-add algorithm

arrays:
+ online algorithms [technical terms around way algorithm uses inputs, eg insertion sort (online) vs selection sort (offline)]

Concept of "low" when talking about complexity classes.

two definitions of NP. Non-deterministic turing machine in polynomial, or checking answer in polynomial
co-NP. check "no" answers in polynomial time. no co-P because all in polynomial time anway. same as P



