<h1 id="propositional-logic"><span class="header-section-number">1</span> Propositional logic</h1>
<h2 id="introduction"><span class="header-section-number">1.1</span> Introduction</h2>
<h3 id="true-and-false"><span class="header-section-number">1.1.1</span> True and False</h3>
<p>We start off with two statements:</p>
<ul>
<li><p>True - <span class="math inline"><em>T</em></span></p></li>
<li><p>False - <span class="math inline"><em>F</em></span></p></li>
</ul>
<h3 id="propositional-variables"><span class="header-section-number">1.1.2</span> Propositional variables</h3>
<p>We can represent <span class="math inline"><em>T</em></span> or <span class="math inline"><em>F</em></span> using a symbol:</p>
<p><span class="math inline"><em>θ</em></span></p>
<h2 id="operators"><span class="header-section-number">1.2</span> Operators</h2>
<h3 id="unary-operators"><span class="header-section-number">1.2.1</span> Unary operators</h3>
<p>A unary operator takes one input and returns another.</p>
<p>Only negation, <span class="math inline">¬</span> is of interest.</p>
<p>The following statements are equivalent:</p>
<ul>
<li><p><span class="math inline"><em>T</em></span></p></li>
<li><p><span class="math inline">¬<em>F</em></span></p></li>
</ul>
<h3 id="binary-operators"><span class="header-section-number">1.2.2</span> Binary operators</h3>
<p>A binary operator takes an additional input.</p>
<ul>
<li><p>If then - <span class="math inline"><em>θ</em> → <em>γ</em></span></p></li>
<li><p>Then if - <span class="math inline"><em>θ</em> ← <em>γ</em></span></p></li>
<li><p>Iff - <span class="math inline"><em>θ</em> ↔ <em>γ</em></span></p></li>
<li><p>And / Conjunction - <span class="math inline"><em>θ</em> ∧ <em>γ</em></span></p></li>
<li><p>Or / Disjunction - <span class="math inline"><em>θ</em> ∨ <em>γ</em></span></p></li>
</ul>
<h3 id="brackets"><span class="header-section-number">1.2.3</span> Brackets</h3>
<p>Operators can be shown together, with brackets. For example:</p>
<p><span class="math inline">(<em>α</em> ∨ <em>β</em>)∧<em>γ</em></span></p>
<p>Is not the same as:</p>
<p><span class="math inline"><em>α</em> ∨ (<em>β</em> ∧ <em>γ</em>)</span></p>
<h3 id="clauses-and-horn-clauses"><span class="header-section-number">1.2.4</span> Clauses and horn clauses</h3>
<p>A clause is a disjunction of atomic formulae.</p>
<p><span class="math inline"><em>A</em> ∨ ¬<em>B</em> ∨ <em>C</em></span></p>
<p>This can be written in implicative form.</p>
<p><span class="math inline">(<em>A</em> ∨ ¬<em>B</em>)∨<em>C</em></span></p>
<p><span class="math inline">¬(<em>A</em> ∨ ¬<em>B</em>)→<em>C</em></span></p>
<p><span class="math inline">(¬<em>A</em> ∧ <em>B</em>)→<em>C</em></span></p>
<p>A horn clause is a clause where there is at most one positive literal. This means the implicative takes the form.</p>
<p><span class="math inline">(<em>A</em> ∧ <em>B</em> ∧ <em>C</em>)→<em>X</em></span>.</p>
<h3 id="atomic-formulae"><span class="header-section-number">1.2.5</span> Atomic formulae</h3>
<p>Atomic formulae are those without operators taking more than one input.</p>
<p>Literals, and negative literals, are types of atomic formula.</p>
<p>A literal is a formula with no operators.</p>
<p><span class="math inline"><em>θ</em></span></p>
<p>These are also known as positive literals.</p>
<p>Negative literals are the negation of a literal.</p>
<p><span class="math inline">¬<em>θ</em></span></p>
<h3 id="well-formed-formulae"><span class="header-section-number">1.2.6</span> Well-formed formulae</h3>
<p>A well-formed formula is one which can be given a truth value.</p>
<p>The following is not a well-formed formula:</p>
<p><span class="math inline"><em>θ</em>∧</span></p>
<h3 id="interpretations"><span class="header-section-number">1.2.7</span> Interpretations</h3>
<p>An interpretation assigns meaning to propositional variables in a formula.</p>
<p>For example an interpretation of the formula <span class="math inline"><em>θ</em> ∨ <em>γ</em></span> assigns values to each of <span class="math inline"><em>θ</em></span> and <span class="math inline"><em>γ</em></span>.</p>
<h3 id="satifisable"><span class="header-section-number">1.2.8</span> Satifisable</h3>
<p>A formula is satisfisable if there is some interpretation where it is true.</p>
<p>For example <span class="math inline"><em>θ</em></span> is satisfisable but <span class="math inline"><em>θ</em> ∧ ¬<em>θ</em></span> is not.</p>
<h3 id="tautology"><span class="header-section-number">1.2.9</span> Tautology</h3>
<p>A formula is a tautology if it is true in all interpretations.</p>
<p>Examples of tautologies include:</p>
<ul>
<li><p><span class="math inline"><em>θ</em> ∨ ¬<em>θ</em></span></p></li>
</ul>
<h2 id="semantic-consequence"><span class="header-section-number">1.3</span> Semantic consequence</h2>
<h3 id="semantic-consequence-1"><span class="header-section-number">1.3.1</span> Semantic consequence</h3>
<p>A formula, <span class="math inline"><em>A</em></span>, semantically implies another, <span class="math inline"><em>B</em></span>, if for every interpretation of <span class="math inline"><em>A</em></span>, <span class="math inline"><em>B</em></span> is true.</p>
<p>We show this with:</p>
<p><span class="math inline"><em>A</em> ⊨ <em>B</em></span></p>
<p>Formula <span class="math inline"><em>B</em></span> is satisfisable if there is some <span class="math inline"><em>A</em></span> where this is true.</p>
<p>For example: <span class="math inline"><em>A</em> ∧ <em>B</em> ⊨ <em>A</em></span></p>
<p>Formula <span class="math inline"><em>B</em></span> is a tautology if this is true for any <span class="math inline"><em>A</em></span>. We can also write this as <span class="math inline">⊨<em>B</em></span>.</p>
<h3 id="logical-equivalence"><span class="header-section-number">1.3.2</span> Logical equivalence</h3>
<p>If <span class="math inline"><em>A</em> ⊨ <em>B</em></span> and <span class="math inline"><em>B</em> ⊨ <em>A</em></span> we say that <span class="math inline"><em>A</em></span> and <span class="math inline"><em>B</em></span> are logically equivalent.</p>
<p>This is shown as <span class="math inline"><em>A</em> ⇔ <em>B</em></span>.</p>
<h3 id="how-many-unique-operators-are-there"><span class="header-section-number">1.3.3</span> How many unique operators are there?</h3>
<p>An arbitrary operator takes <span class="math inline"><em>n</em></span> inputs are returns <span class="math inline"><em>T</em></span> or <span class="math inline"><em>F</em></span>.</p>
<p>With <span class="math inline">0</span> inputs there is one posible permutation. For every additional input the number of possible permutations doubles. Therefore there are <span class="math inline">2<sup><em>n</em></sup></span> possible permutations.</p>
<p>For the operator with one permutation there are two operators. For every additional permutation the number of operator doubles. Therefore there are <span class="math inline">2<sup>(2<sup><em>n</em></sup>)</sup></span> possible operations.</p>
<p>With <span class="math inline">0</span> inputs, we need <span class="math inline">2</span> different operators to cover all outputs. For <span class="math inline">1</span> input we need <span class="math inline">4</span> and for <span class="math inline">2</span> inputs we need <span class="math inline">16</span>.</p>
<h3 id="we-dont-need-0-ary-operators"><span class="header-section-number">1.3.4</span> We don’t need <span class="math inline">0</span>-ary operators</h3>
<p>There are two unique <span class="math inline">0</span>-ary operators. One always returns <span class="math inline"><em>T</em></span> and the other always returns <span class="math inline"><em>F</em></span>. These are already described.</p>
<h3 id="we-need-one-unary-operator"><span class="header-section-number">1.3.5</span> We need one unary operator</h3>
<p>For the operators with <span class="math inline">1</span> input we have:</p>
<ul>
<li><p>one which always returns <span class="math inline"><em>T</em></span></p></li>
<li><p>one which always returns <span class="math inline"><em>F</em></span></p></li>
<li><p>one which always returns the same as the input</p></li>
<li><p>one which returns the opposite of the input</p></li>
</ul>
<p>It is this last one, negation, shown as <span class="math inline">¬</span> and is of most interest.</p>
<h3 id="we-can-use-a-subset-of-binary-operators"><span class="header-section-number">1.3.6</span> We can use a subset of binary operators</h3>
<p>The full list of binary operators are included below.</p>
<p>Of these, the first two are <span class="math inline">0</span>-ary operators, and so are not needed. The next four are unary operators, and so are not needed.</p>
<p>The non-implications can be rewritten using negation.</p>
<h3 id="brackets-replace-the-need-for-n-ary-operators"><span class="header-section-number">1.3.7</span> Brackets replace the need for n-ary operators</h3>
<p>N-ary operators contain <span class="math inline">3</span> or more inputs.</p>
<p>N-ary operators can be defined in terms of binary operators.</p>
<p>As an example if we want an operator to return positive if all inputs are true, we can use:</p>
<p><span class="math inline">(<em>θ</em> ∧ <em>γ</em>)∧<em>β</em></span></p>
<h3 id="de-morgans-laws"><span class="header-section-number">1.3.8</span> De Morgan’s Laws</h3>
<ul>
<li><p><span class="math inline">¬(<em>A</em> ∨ <em>B</em>)⇔(¬<em>A</em> ∧ ¬<em>B</em>)</span></p></li>
<li><p><span class="math inline">¬(<em>A</em> ∧ <em>B</em>)⇔(¬<em>A</em> ∨ ¬<em>B</em>)</span></p></li>
</ul>
<p>This expresses the duality of normal form.</p>
<p>Duality is the principle that binary operators have inverses, and when they are swapped with their inverse, the truth value of the statement is unaffected.</p>
<h3 id="normal-form"><span class="header-section-number">1.3.9</span> Normal form</h3>
<p>This is where a formula is shown using only:</p>
<ul>
<li><p>And / Conjunction- <span class="math inline">∧</span></p></li>
<li><p>Or / Disjunction - <span class="math inline">∨</span></p></li>
<li><p>Negation - <span class="math inline">¬</span></p></li>
</ul>
<p>The conjunctive normal form (CNF) is where a formula is converted to a normal form with the following layout:</p>
<p><span class="math inline"><em>a</em> ∧ <em>b</em> ∧ <em>c</em> ∧ <em>d</em></span></p>
<p>These letters can represent complex sub-formulae, in normal form.</p>
<p>Statements in this form are easier to evaluate, as each subformula can be evaluated separately. The statement is true only if all formulaes within are also true.</p>
<p>The disjunctive normal form (DNF) is similar for <span class="math inline">∨</span>.</p>
<p><span class="math inline"><em>a</em> ∨ <em>b</em> ∨ <em>c</em> ∨ <em>d</em></span></p>
<h3 id="properties-of-the-normal-form"><span class="header-section-number">1.3.10</span> Properties of the normal form</h3>
<p>The normal binary operators are commutitive - <span class="math inline"><em>A</em> ∧ <em>B</em> ⇔ <em>B</em> ∧ <em>A</em></span> and <span class="math inline"><em>A</em> ∨ <em>B</em> ⇔ <em>B</em> ∨ <em>A</em></span></p>
<p>Both binary operators are associative - <span class="math inline">(<em>A</em> ∧ <em>B</em>)∧<em>C</em> ⇔ <em>A</em> ∧ (<em>B</em> ∧ <em>C</em>)</span> and <span class="math inline">(<em>A</em> ∨ <em>B</em>)∨<em>C</em> ⇔ <em>A</em> ∨ (<em>B</em> ∨ <em>C</em>)</span></p>
<p>Negation is complementary.</p>
<p><span class="math inline"><em>A</em> ∧ ¬<em>A</em> ⇔ <em>F</em></span></p>
<p><span class="math inline"><em>A</em> ∨ ¬<em>A</em> ⇔ <em>T</em></span></p>
<p>Normal binary operators are absorbative.</p>
<p><span class="math inline"><em>A</em> ∧ (<em>A</em> ∨ <em>B</em>)⇔<em>A</em></span> <span class="math inline"><em>A</em> ∨ (<em>A</em> ∧ <em>B</em>)⇔<em>A</em></span></p>
<p>Identity.</p>
<p><span class="math inline"><em>A</em> ∧ <em>T</em> ⇔ <em>A</em></span></p>
<p><span class="math inline"><em>A</em> ∨ <em>F</em> ⇔ <em>A</em></span></p>
<p>Distributivity.</p>
<p><span class="math inline"><em>A</em> ∧ (<em>B</em> ∨ <em>C</em>)⇔(<em>A</em> ∧ <em>B</em>)∨(<em>A</em> ∧ <em>C</em>)</span></p>
<p><span class="math inline"><em>A</em> ∨ (<em>B</em> ∧ <em>C</em>)⇔(<em>A</em> ∨ <em>B</em>)∧(<em>A</em> ∨ <em>C</em>)</span></p>
<h2 id="inference"><span class="header-section-number">1.4</span> Inference</h2>
<h3 id="substitution"><span class="header-section-number">1.4.1</span> Substitution</h3>
<p>If we have a tautology, then we can substitute the formula of any propositional variable with any formula to arrive at any other tautology.</p>
<p>For example, we know that <span class="math inline"><em>θ</em> ∨ ¬<em>θ</em></span> is a tautology. This means that an arbitrary formula for <span class="math inline"><em>θ</em></span> is also a tautology.</p>
<p>An example is <span class="math inline">(<em>γ</em> ∧ <em>α</em>)∨¬(<em>γ</em> ∧ <em>α</em>)</span>, which we know is a tautology, without having to examine each variable.</p>
<h3 id="syntactic-consequence"><span class="header-section-number">1.4.2</span> Syntactic consequence</h3>
<p>Let us call the first formula <span class="math inline"><em>A</em></span> and the second <span class="math inline"><em>B</em></span>. We can then say:</p>
<p><span class="math inline"><em>A</em> ⊢ <em>B</em></span></p>
<p>This says that: if <span class="math inline"><em>A</em></span> is true, then we can deduce that <span class="math inline"><em>B</em></span> is true using steps such as substitution.</p>
<h3 id="modus-ponens"><span class="header-section-number">1.4.3</span> Modus Ponens</h3>
<p>Modus Ponens is a deduction rule. This allows us to use stpes other than substitution to derive new tautologies.</p>
<p>If <span class="math inline"><em>A</em></span> implies <span class="math inline"><em>B</em></span>, and <span class="math inline"><em>A</em></span> is true, then <span class="math inline"><em>B</em></span> is also true.</p>
<p><span class="math inline">(<em>θ</em> → <em>γ</em>)∧<em>θ</em> ⇒ <em>γ</em></span></p>
<p>That is, if we can show that the following are true:</p>
<p><span class="math inline"><em>θ</em> → <em>γ</em></span></p>
<p><span class="math inline"><em>θ</em></span></p>
<p>We can infer that the following is also true:</p>
<p><span class="math inline"><em>γ</em></span></p>
<h3 id="inference-with-horn-clauses"><span class="header-section-number">1.4.4</span> Inference with horn clauses</h3>
<p>If the horn clause is true, and so is the normal form part, then <span class="math inline"><em>X</em></span> is also true.</p>
<p>As all inference with horn clauses uses Modus Ponens, it is sound.</p>
<p>Inference with horn clauses is also complete.</p>
<h3 id="theory"><span class="header-section-number">1.4.5</span> Theory</h3>
<p>Results derived from substitution or induction are called theorems. Theorems often divided into:</p>
<ul>
<li><p>Theorems - important results</p></li>
<li><p>Lemmas - results used for later theorems</p></li>
<li><p>Corollaries - readily deduced from a theorem</p></li>
</ul>
<p>We take a set of axioms, as true, and a deduction rule which enables us to derive additional formulae, or theorems. The collection of axioms and theorems is known as the theory.</p>
<h3 id="principle-of-explosion"><span class="header-section-number">1.4.6</span> Principle of explosion</h3>
<p>If axioms contradict each other then it is possible to derive anything. That is:</p>
<p><span class="math inline"><em>P</em> ∧ ¬<em>P</em> ⊢ <em>Q</em></span></p>
<p>We can prove this. If <span class="math inline"><em>P</em></span> and <span class="math inline">¬<em>P</em></span> are true, then the following is also true:</p>
<p><span class="math inline"><em>P</em> ∨ <em>Q</em></span></p>
<p>We can then use <span class="math inline"><em>P</em> ∨ <em>Q</em></span> and <span class="math inline">¬<em>P</em></span> to imply <span class="math inline"><em>Q</em></span>.</p>
<p>This works for any proposition <span class="math inline"><em>Q</em></span>, including <span class="math inline">¬<em>Q</em></span>.</p>
<p>As we can derive <span class="math inline"><em>Q</em></span> and <span class="math inline">¬<em>Q</em></span>, our axioms are not consistent.</p>
<h3 id="resolution-rule"><span class="header-section-number">1.4.7</span> Resolution rule</h3>
<h4 id="proof-by-resolution"><span class="header-section-number">1.4.7.1</span> Proof by resolution</h4>
<p>If we have a string of or statements, <span class="math inline"><em>A</em> ∨ <em>B</em> ∨ <em>C</em></span>, and another which contains the completement of one element <span class="math inline"><em>X</em> ∨ ¬<em>B</em> ∨ <em>Y</em></span>, we can infer:</p>
<p><span class="math inline"><em>A</em> ∨ <em>C</em> ∨ <em>X</em> ∨ <em>Y</em></span></p>
<p>If the second statement has only one formula, then we have:</p>
<p><span class="math inline"><em>A</em> ∨ <em>B</em> ∨ <em>C</em></span> and <span class="math inline">¬<em>B</em></span> implying <span class="math inline"><em>A</em> ∨ <em>C</em></span></p>
<h2 id="axioms-for-propositional-logic"><span class="header-section-number">1.5</span> Axioms for propositional logic</h2>
<h3 id="motivation-for-axioms-for-propositional-logic"><span class="header-section-number">1.5.1</span> Motivation for axioms for propositional logic</h3>
<p>We discussed in the previous section the ability to derive new tautologies from others using substitution and Modus Ponens.</p>
<p>We now aim to identify a group of axioms from which all tautologies can be derived.</p>
<h3 id="the-axioms"><span class="header-section-number">1.5.2</span> The axioms</h3>
<p>The first is known as “Simplification”. In words, this is “if it is cloudy, then if it is a Tuesday it is also cloudy.”</p>
<p><span class="math inline"><em>θ</em> → (<em>γ</em> → <em>θ</em>)</span></p>
<p>The second is called “Frege”.</p>
<p><span class="math inline">(<em>α</em> → (<em>β</em> → <em>γ</em>)) → ((<em>α</em> → <em>β</em>)→(<em>α</em> → <em>γ</em>))</span></p>
<p>The third is “Transposition”. Consider the statement “If there are no clouds in the sky, it is not raining.” If this is true then it is also true that “If it is raining there are clouds in the sky.”</p>
<p><span class="math inline">(¬<em>θ</em> → ¬<em>γ</em>)→(<em>γ</em> → <em>θ</em>)</span></p>
<h3 id="independence-of-axioms"><span class="header-section-number">1.5.3</span> Independence of axioms</h3>
<p>These axioms are independent. That is, if you take one away, you cannot derive it from the others.</p>
<p>These axioms are also effective. One could define all true formulae as axioms, however this is not effective.</p>
<h3 id="soundness-of-axioms"><span class="header-section-number">1.5.4</span> Soundness of axioms</h3>
<p>Soundness implies that all theories are true.</p>
<p><span class="math inline"><em>T</em> ⊢ <em>A</em> ⇒ <em>T</em> ⊨ <em>A</em></span></p>
<p>These axioms and the deduction rule are sound. We know that the axioms are tautologies, and we know that the inference rule is valid.</p>
<p>As the axioms are sound, the theories are consistent. That is, it is not possible for both <span class="math inline"><em>θ</em></span> and <span class="math inline">¬<em>θ</em></span> to be theories.</p>
<h3 id="completeness-of-axioms"><span class="header-section-number">1.5.5</span> Completeness of axioms</h3>
<p>Completeness implies that all true formulae are theories.</p>
<p><span class="math inline"><em>T</em> ⊨ <em>A</em> ⇒ <em>T</em> ⊢ <em>A</em></span></p>
<h3 id="axioms-and-definitions"><span class="header-section-number">1.5.6</span> Axioms and definitions</h3>
<p>A definition is a conservative extension of the language. A definition statement, for example that a new symbol <span class="math inline"><em>Z</em></span> is always evaluated as false allows us to make additional statements, but it does not allow us to make additional statements in the original language.</p>
<p>An axiom allows us to generate additional statements in the original language, a definition does not.</p>
